# lambda_function.py
import os
import json
import urllib.request

# Env variables (set these in Lambda configuration)
OPENAI_API_KEY = os.environ["OPENAI_API_KEY"]      # set in Lambda env
TELEGRAM_TOKEN = os.environ["TELEGRAM_TOKEN"]      # set in Lambda env
TELEGRAM_SECRET = os.getenv("TELEGRAM_SECRET")     # optional, but recommended

OAI_URL = "https://api.openai.com/v1/chat/completions"
OAI_HEADERS = {
    "Authorization": f"Bearer {OPENAI_API_KEY}",
    "Content-Type": "application/json",
}

TRIGGER_KEYWORD = "quoteoftheday"  # we still keep this constant for clarity


def _http(url, payload=None, headers=None, method=None, timeout=10):
    """Small helper for HTTP requests."""
    data = None if payload is None else json.dumps(payload).encode("utf-8")
    m = method or ("POST" if data is not None else "GET")
    req = urllib.request.Request(url, data=data, headers=headers or {}, method=m)
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return resp.status, resp.read()

def lambda_handler(event, context):
    print("HANDLER: QuoteOfTheDay bot")

    # 1) Verify Telegram secret header (protects your Function URL)
    if TELEGRAM_SECRET:
        hdrs = event.get("headers") or {}
        got = (
            hdrs.get("X-Telegram-Bot-Api-Secret-Token")
            or hdrs.get("x-telegram-bot-api-secret-token")
        )
        if got != TELEGRAM_SECRET:
            print("Invalid Telegram secret token:", got)
            return {"statusCode": 403, "body": "forbidden"}

    # 2) Parse Telegram update body
    try:
        update = json.loads(event.get("body") or "{}")
    except Exception as e:
        print("Bad JSON in event body:", e, "event:", event)
        return {"statusCode": 400, "body": "bad json"}

    msg = update.get("message") or update.get("edited_message") or {}
    text = (msg.get("text") or "").strip()
    chat = msg.get("chat") or {}
    chat_id = chat.get("id")

    print("INCOMING TEXT:", repr(text), "CHAT ID:", chat_id)

    if not chat_id:
        # Nothing to reply to
        return {"statusCode": 200, "body": "ok"}

    # 3) Only respond if the message is exactly "quoteoftheday"
    if text.lower().strip() != TRIGGER_KEYWORD:
        return {"statusCode": 200, "body": "ok"}

    # 4) Ask OpenAI
    try:
        status, body = _http(
            OAI_URL,
            payload={
                "model": "gpt-4.1-mini",
                "messages": [
                    {
                        "role": "system",
                        "content": (
                            "You are a quote-of-the-day generator bot. "
                            "Always reply with ONE short, unique inspirational quote, "
                            "then a newline and the author. No extra explanation."
                        ),
                    },
                    {
                        "role": "user",
                        "content": "Give me today's quote of the day.",
                    },
                ],
                "temperature": 2.0,
            },
            headers=OAI_HEADERS,
            timeout=8,  # shorter than Lambda timeout
        )
        oai_resp = json.loads(body)
        reply_text = oai_resp["choices"][0]["message"]["content"]
        print("OpenAI status:", status)
    except Exception as e:
        print("OpenAI error:", e)
        reply_text = f"OpenAI error: {e}"

    # 5) Send reply back to Telegram
    tg_url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    try:
        _http(
            tg_url,
            payload={"chat_id": chat_id, "text": reply_text},
            headers={"Content-Type": "application/json"},
        )
        print("Sent reply to Telegram.")
    except Exception as e:
        print("Error sending message to Telegram:", e)

    return {"statusCode": 200, "body": "ok"}